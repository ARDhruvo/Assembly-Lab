.MODEL SMALL
.STACK 100H

.DATA
INV DB 0AH, 0DH, 'INVALID INPUT', 0AH, 0DH, '$'
IN1 DB 'ENTER FIRST 4 DIGIT HEX NUMBER (0 - FFFFH): $'
IN2 DB 0AH, 0DH, 'ENTER SECOND 4 DIGIT HEX NUMBER (0 - FFFFH): $'
SUM DB 0AH, 0DH, 'SUM: $'
CNT DB 0
NUM DB 1
TMP DW 0

.CODE
MAIN PROC
    ; INITIALIZING DS
    MOV AX, @DATA
    MOV DS, AX
    
    RESET:      ; CLEARING REGISTERS
    XOR AX, AX
    XOR BX, BX
    XOR CX, CX
    XOR DX, DX
    MOV CNT, 0  ; RESETS COUNTER
    MOV NUM, 1  ; RESETS TO INPUT NUMBER 1
    
    INPUT:
    LEA DX, IN1
    MOV AH, 9
    INT 21H
    
    NEXT:
    MOV AH, 1
    INT 21H
    
    ; COMPARISON
    CMP AL, 0DH ; IF INP == RETURN
    JNE COMP    ; IF INP != RETURN -> COMP()
    CMP CNT, 0  ; IF THERE HASN'T BEEN ANY INPUT YET
    JE INVALID  ; IF INP == RETURN && CNT == 0 -> INVALID()
    MOV CNT, 0  ; SETS COUNT TO 0 FOR SECOND INPUT
    CMP NUM, 1
    JE SECOND   ; IF INPUT NUMBER == 1 -> SECOND INPUT
    MOV CNT, 4  ; IF BOTH INPUTS ARE TAKEN AND ENTER IS PRESSED
    JMP OUTPUT  ; IF INP == RETURN && CNT != 0 -> OUTPUT()
    
    COMP:
    CMP AL, '0'
    JL INVALID  ; IF INP < '0' -> INVALID()
    
    CMP AL, '9' 
    JG COMPAL   ; IF INP < '0' && INP > '9' -> COMPARE FOR A-F
    
    JMP STORE   ; ELSE START STORING THE INPUT
    
    COMPAL:     ; COMPARING FOR A-F
    CMP AL, 'F' 
    JG INVALID  ; IF INP > 'F' -> INVALID()
    
    CMP AL, 'A' 
    JL INVALID  ; IF INP > 'F' && INP < 'A' -> INVALID()
    
    ADD AL, 09H ; CONVERTS TO ASCII EQUIVALENT OF 'A' - 'F'       
    
    STORE:
    AND AL, 0FH
    MOV CL, 4
    SHL AL, CL  ; MULTIPLIES BY 16D OR 10H
    
    MOV CX, 4   ; INITIALIZES LOOP
    
    SHIFT:
    SHL AL, 1   ; MOVES AL'S BIT LEFT TO CARRY
    RCL BX, 1   ; SHIFTS CARRY TO FIRST BIT OF BX
    
    LOOP SHIFT
           
    INC CNT
    CMP CNT, 4  ; CHECKS IF 4TH HEX DIGIT IS REACHED
    JNE NEXT    ; IF NOT 4 IT TAKES THE NEXT BIT
    CMP NUM, 2  ; IF INPUT IS 2
    JE OUTPUT   ; IF INPUT == 2 -> OUTPUT()
    MOV CNT, 0  ; RESETS COUNTER TO TAKE INPUT AGAIN
    
    SECOND:
    INC NUM     ; SETS TO SECOND INPUT
    MOV TMP, BX ; STORES THE FIRST INPUT IN TMP
    XOR BX, BX  ; CLEARS BX
    LEA DX, IN2
    MOV AH, 9
    INT 21H
    JMP NEXT    ; TAKES THE SECOND INPUT
    
    OUTPUT:
    LEA DX, SUM
    MOV AH, 9
    INT 21H
    
    MOV AH, 2
    
    ADD BX, TMP ; PERFORMS THE REQUIRED SUM
    JNC RESULT  ; IF CF == 0 -> RESULT()
    MOV DL, '1' ; ELSE PRINT 1 IN FRONT
    INT 21H
    
    RESULT:
    MOV CX, 4   ; LOOPS 4 TIMES FOR 4 BITS
    XOR DL, DL  ; CLEARING DL FOR EVERY LOOP
    
    CONV:       ; CONVERTS EACH BIT TO HEX BY RUNNING IT 4 TIMES
    SHL BX, 1   
    RCL DL, 1
    LOOP CONV   ; UPDATES EACH ONE TO 16 BITS
    
    CMP DL, 9   ; CHECKS IF INP IS NUMBER
    JLE NUMB    ; IF INP <= 9 -> NUMBER_CONVERSION()
    SUB DL, 9   ; RESETS THE VALUE BY 9
    OR DL, 40H  ; SETS THE VALUE TO 4X ON DL FOR A-F
    JMP PRINT  
    
    NUMB:
    OR DL, 30H  ; SETS THE VALUE TO 3X ON DL
    
    PRINT:
    INT 21H
    
    DEC CNT     ; DECREASES COUNTER FOR NUMBER OF BITS
    JNZ RESULT  ; LOOPS UNTIL END OF BITS IS REACHED
    
    JMP EXIT
        
    INVALID:
    LEA DX, INV
    MOV AH, 9
    INT 21H
    JMP RESET

    EXIT:
    MOV AH,4CH
    INT 21H
    END MAIN